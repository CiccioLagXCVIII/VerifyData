# Documentazione Architetturale VerifyData

Questo documento descrive la logica funzionale e i contenuti di ogni pagina della DApp **VerifyData**.

## 1. Architettura delle Pagine

### `index.html` (Hub Informativo)
**Scopo:** Educare l'utente e presentare il progetto.
- **Contenuti:**
    - Hero section con la "Value Proposition" (Perché usare la blockchain per i tuoi documenti?).
    - Sezione "Come Funziona": Spiegazione visiva del processo di Hashing (File -> Hash -> Blockchain).
    - Vantaggi: Immutabilità, Privacy (il file non lascia il PC), Identità Sovrana (SBT).
- **Logica:** Pagina statica, non richiede connessione al wallet per la lettura.

### `connessione.html` (Gateway di Accesso)
**Scopo:** Gestire l'onboarding dell'utente nel Web3.
- **Contenuti:**
    - Card dinamica che cambia stato in base alla connessione.
    - Pulsante "Connetti MetaMask".
    - Messaggi di errore se il wallet non è installato.
- **Logica ad alto livello:**
    1. **Stato 1 (Disconnesso):** Mostra il tasto di connessione.
    2. **Stato 2 (Connesso, No SBT):** Rileva l'indirizzo dal wallet, nota che non ha un'identità SBT e mostra il tasto "Richiedi Identità Digitale".
    3. **Stato 3 (Connesso + SBT):** Mostra i dettagli dell'identità e reindirizza al Profilo.

### `certifica.html` (Notarization Engine)
**Scopo:** Effettuare la marcatura temporale del documento.
- **Contenuti:**
    - Area Drag & Drop per il caricamento file.
    - Anteprima nome file e calcolo in tempo reale dell'Hash SHA-256.
    - Pulsante "Registra su Blockchain" (disabilitato se l'utente non è loggato o non ha l'SBT).
- **Logica ad alto livello:**
    1. L'utente carica il file.
    2. JavaScript calcola l'hash localmente (usando `SubtleCrypto.digest`).
    3. Al click su "Registra", viene invocato lo Smart Contract passando l'hash come parametro.
    4. Feedback di attesa della transazione e conferma finale.

### `profilo.html` (Personal Ledger & Identity)
**Scopo:** Gestione dello storico e della propria identità.
- **Contenuti:**
    - Visualizzazione del proprio badge SBT (Identità Sovrana).
    - Tabella dei documenti certificati (Data, Nome File, Hash, Stato).
    - Azione di "Revoca" per ogni documento.
- **Logica ad alto livello:**
    1. Al caricamento, interroga la blockchain filtrando i documenti creati dall'indirizzo connesso.
    2. Se l'utente clicca su "Revoca", viene inviata una transazione allo Smart Contract per cambiare lo stato di quel certificato da `valid` a `revoked`.

### `verifica.html` (Public Validator)
**Scopo:** Permettere a chiunque (anche senza wallet) di verificare un documento ricevuto.
- **Contenuti:**
    - Area di upload per il file da controllare.
    - Pannello dei risultati (Verde: Valido / Rosso: Non trovato o Revocato).
    - Dettagli: Chi ha firmato il documento e quando.
- **Logica ad alto livello:**
    1. Calcola l'hash del file caricato.
    2. Interroga la blockchain (funzione `read-only`) per vedere se quell'hash esiste nel registro.
    3. Se esiste, recupera l'indirizzo del firmatario e controlla se ha un SBT valido.

---

## 2. Logica di Stato Locale (Local Storage)

Per garantire una navigazione fluida, useremo il `localStorage` per persistere lo stato della sessione:

- `isLoggedIn`: Boolean (true/false).
- `userAddress`: String (L'indirizzo del wallet connesso).
- `hasSBT`: Boolean (Indica se l'utente ha già riscattato la propria identità).

**Regole di accesso:**
- Se un utente prova ad accedere a `certifica.html` o `profilo.html` e `isLoggedIn` è `false`, viene automaticamente reindirizzato a `connessione.html`.

## 3. Sicurezza e Privacy (Principi seguiti)

1. **Zero-Knowledge Proof of Content:** Non carichiamo mai il contenuto del file. Solo l'impronta digitale (hash) tocca la rete.
2. **Identity Linkage:** Solo chi possiede l'SBT può apparire come "Firmatario Verificato", prevenendo lo spam di notarizzazioni anonime.
3. **Immutabilità Dinamica:** La blockchain garantisce che la data di certificazione sia certa, ma la logica di revoca permette la gestione del ciclo di vita del documento.

---

### Prossimi passi consigliati:
1.  **Rinomina i file** come indicato nella tabella.
2.  **Crea il CSS globale (`style.css`)** definendo i colori del brand (consiglio un blu scuro/viola per un look "Cyber/Security").
3.  **Configura `main.js`** iniziando a scrivere la funzione di hashing locale.